<!DOCTYPE html>
<html>
	<head>
	<title>HTML5 WebGL test</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<style type="text/css">
		html, body{
			background-color: #000;
			margin: 0px;
		}
		canvas {
			width:100%;
			height: 100%;
			margin-left: auto;
			margin-right: auto;
		}
		</style>
	</head>
	<body>
		<script id="vshader" type="VERTEX_SHADER/GSLS">
precision lowp float;
attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec4 a_color;
attribute vec3 a_objPos;
attribute float a_objScale;
attribute float a_offSet;
uniform mat4 viewMat;
uniform mat4 perspMatrix;
uniform float time;
varying vec3 normal;
varying vec3 pos;
varying vec4 color;
void main() {
	color = a_color;
	float a = sin((time-a_offSet)/750.0)*2.0;
	mat4 objMat = mat4(a_objScale,0.0,0.0,a_objPos.x,0.0,a_objScale,0.0,a_objPos.y,0.0,0.0,a_objScale,a_objPos.z-a,0.0,0.0,0.0,1.0);
	normal = a_normal*mat3(objMat);
	pos = vec3(a_position*objMat);
	gl_Position = a_position*objMat*viewMat*perspMatrix;
}
		</script>
		<script id="fshader" type="FRAGMENT_SHADER/GSLS">
precision lowp float;
uniform vec3 lightPos[8];
uniform vec3 lightColor[8];
uniform float lightStr[8];
varying vec3 normal;
varying vec3 pos;
varying vec4 color;
void main() {
	vec3 mulColor = vec3(0.0,0.0,0.0);
	for (int i=0;i<2;i++) {
		if ( lightStr[i] == 0.0) {
			break;
		}
		float dis = sqrt(((lightPos[i].x-pos.x)*(lightPos[i].x-pos.x))+((lightPos[i].y-pos.y)*(lightPos[i].y-pos.y))+((lightPos[i].z-pos.z)*(lightPos[i].z-pos.z)));
		float str = (lightStr[i]-dis)/lightStr[i];
		float d = dot(normalize(lightPos[i]-pos),normalize(normal))*str;
		if (str < 0.0 || d < 0.0) {
			continue;
		}
		mulColor = vec3(mulColor.x+lightColor[i].x*d,mulColor.y+lightColor[i].y*d,mulColor.z+lightColor[i].z*d);
	}
	if (mulColor.x>255.0) {
		mulColor.x=255.0;
	} if (mulColor.y>255.0) {
		mulColor.y=255.0;
	} if (mulColor.z>255.0) {
		mulColor.z=255.0;
	}
	gl_FragColor = vec4(mulColor.x/255.0*color.x,mulColor.y/255.0*color.y,mulColor.z/255.0*color.z,color.w);
}
		</script>
		<script></script>
		<canvas id="canvas" style="height:100%;width:100%;cursor: default;position:absolute;"></canvas>
		<script type="text/javascript">
window.onload = init;
function init() {

	var canvas = document.getElementById("canvas");
	if (canvas===null) {
		console.error("Error: can not get canvas.");
		return false;
	}
	var gl = canvas.getContext("webgl",{antialias:true});
	if (gl===null) {
		gl = canvas.getContext("experimental-webgl",{antialias:true});
		if (gl===null) {
			gl = canvas.getContext("webgl");
			if (gl===null) {
				gl = canvas.getContext("experimental-webgl");
				if (gl===null) {
					console.error("Error: can not get WebGL context.");
					return false;
				}
			}
		}
	}
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);


	var t = new Date();


	var lookDistance = 250;
	var transition = {"X":0,"Y":0,"Z":0};
	var keys = [];
	var width;
	var height;
	var mouseX = 0;
	var mouseY = 0;
	var mouseDown = false;
	var rotX = 0, rotY = 0;
	var dateObj;
	var time;
	var renderWidth = 1680;
	var renderHeight = 1050;
	var aspect = renderWidth/renderHeight;
	var perspMatrix;
	window.onresize = resize;
	window.onkeydown = keysDown;
	window.onkeyup = keysUp;
	window.onwheel = wheel;
	canvas.onmousemove = mouseMove;
	canvas.oncontextmenu = contextMenu;
	canvas.onmousedown = mouseClickDown;
	canvas.onmouseup = mouseClickUp;
	canvas.onmouseout = mouseClickUp;
	resize();
	gl.clearColor(0, 0, 0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);

	gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
	var program = createProgramFromScripts(
	gl, ["vshader", "fshader"],["a_position","a_normal","a_color","a_objPos","a_objScale","a_offSet"],
									[0,			1,			2,			3,			4,		5]);
	gl.useProgram(program);



	
	program.lightPos = gl.getUniformLocation(program,"lightPos");
	program.lightColor = gl.getUniformLocation(program,"lightColor");
	program.lightStr = gl.getUniformLocation(program,"lightStr");
	program.viewMat = gl.getUniformLocation(program,"viewMat");
	program.perspMatrix = gl.getUniformLocation(program,"perspMatrix");
	program.scale = gl.getUniformLocation(program,"scale");
	program.time = gl.getUniformLocation(program,"time");

	var index = [0, 1, 2,    0, 2, 3,    4, 5, 6,
				 4, 6, 7,    8, 9,10,    8,10,11,
				12,13,14,   12,14,15,   16,17,18,
				16,18,19,   20,21,22,   20,22,23];
	var verts = [-1,-1, 1,
		 1,-1, 1,
		 1, 1, 1,
		-1, 1, 1,

		-1,-1,-1,
		-1, 1,-1,
		 1, 1,-1,
		 1,-1,-1,

		-1, 1,-1,
		-1, 1, 1,
		 1, 1, 1,
		 1, 1,-1,

		-1,-1,-1,
		 1,-1,-1,
		 1,-1, 1,
		-1,-1, 1,

		 1,-1,-1,
		 1, 1,-1,
		 1, 1, 1,
		 1,-1, 1,

		-1,-1,-1,
		-1,-1, 1,
		-1, 1, 1,
		-1, 1,-1];
	var norms = [0,0,1,
		0,0,1,
		0,0,1,
		0,0,1,
		
		0,0,-1,
		0,0,-1,
		0,0,-1,
		0,0,-1,

		0,1,0,
		0,1,0,
		0,1,0,
		0,1,0,

		0,-1,0,
		0,-1,0,
		0,-1,0,
		0,-1,0,

		1,0,0,
		1,0,0,
		1,0,0,
		1,0,0,

		-1,0,0,
		-1,0,0,
		-1,0,0,
		-1,0,0];
	var vertexs = [];
	var normals = [];
	for (var i = 0; i < index.length; i++) {
		vertexs=vertexs.concat(verts[index[i]*3],verts[index[i]*3+1],verts[index[i]*3+2]);
		normals=normals.concat(norms[index[i]*3],norms[index[i]*3+1],norms[index[i]*3+2]);
	};
	var av=[];
	var an=[];
	var ac=[];
	var as=[];
	var ao=[];
	var tempObjArray=[];
	
	for(var i=-109;i<110;i++)
	{
		for(var j=-109;j<110;j++)
		{
			for(var k=0;k<36;k++)
			{
				av.push(vertexs[k*3],vertexs[k*3+1],vertexs[k*3+2]);
				an.push(normals[k*3],normals[k*3+1],normals[k*3+2]);
				ac.push((i+109.0)/219.0,(j+109.0)/219.0,1,1);
				as.push(0.5);
				ao.push((i+109)*(j+109));
				tempObjArray.push(i,j,-50);
			}
		}
	}
	
	for(var i=-109;i<110;i++)
	{
		for(var j=-109;j<110;j++)
		{
			for(var k=0;k<36;k++)
			{
				av.push(vertexs[k*3],vertexs[k*3+1],vertexs[k*3+2]);
				an.push(normals[k*3],normals[k*3+1],normals[k*3+2]);
				ac.push((i+109.0)/219.0,1,(j+109.0)/219.0,1);
				as.push(0.5);
				ao.push((i+109)*(j+109));
				tempObjArray.push(i,j,50);
			}
		}
	}
	console.log(tempObjArray.length);
	console.log(av.length);
	console.log(an.length);

	var vertBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
	gl.enableVertexAttribArray(0);
	gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(av), gl.STATIC_DRAW);


	var normBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
	gl.enableVertexAttribArray(1);
	gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(an), gl.STATIC_DRAW);


	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
	gl.enableVertexAttribArray(2);
	gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ac), gl.STATIC_DRAW);

	
	var objBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, objBuffer);
	gl.enableVertexAttribArray(3);
	gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tempObjArray), gl.STATIC_DRAW);

	
	var scaleBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, scaleBuffer);
	gl.enableVertexAttribArray(4);
	gl.vertexAttribPointer(4, 1, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(as), gl.STATIC_DRAW);

	
	var OffSetBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, OffSetBuffer);
	gl.enableVertexAttribArray(5);
	gl.vertexAttribPointer(5, 1, gl.FLOAT, false, 0, 0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ao), gl.STATIC_DRAW);


	var l=tempObjArray.length/3;

	av=[];
	an=[];
	ac=[];
	as=[];
	tempObjArray=[];







	var lights=[[0.0,0.0,200.0,  0.0,0.0,-200.0],
				[255.0,255.0,255.0,  255.0,255.0,255.0],
				[20000, 20000]];


	window.requestAnimationFrame(render);




	function render() {
		if(gl.getError())
			console.log("Gl error");
		dateObj = new Date();
		var passedTime = dateObj.getTime()-time;
		if (keys[38]) {
			transition.Z -= 0.003125*(passedTime);
		} if (keys[40]) {
			transition.Z += 0.003125*(passedTime);
		} if (keys[37]) {
			transition.X += 0.003125*(passedTime);
		} if (keys[39]) {
			transition.X -= 0.003125*(passedTime);
		}

		time = dateObj.getTime();
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
		gl.uniform3fv(program.lightPos, lights[0]);
		gl.uniform3fv(program.lightColor, lights[1]);
		gl.uniform1fv(program.lightStr, lights[2]);
		var viewMat = createTransformation([-rotY/2, -rotX/2, 0.0],[transition.X, transition.Y, transition.Z-lookDistance],[-transition.X, -transition.Y, -transition.Z],1);
		gl.uniformMatrix4fv(program.viewMat,false , viewMat);
		gl.uniformMatrix4fv(program.perspMatrix,false , perspMatrix);
		gl.uniform1f(program.time, dateObj.getTime()-t.getTime());


		gl.drawArrays(gl.TRIANGLES, 0, l);

		window.requestAnimationFrame(render);
	}
	function resize() {
		height = "innerHeight" in window 
			? window.innerHeight
			: document.documentElement.offsetHeight;
		width = "innerWidth" in window 
			? window.innerWidth
			: document.documentElement.offsetWidth;

		canvas.height = height;
		canvas.width = width;
		aspect = width / height;

		perspMatrix = createPerspective(45/180*3.14, aspect, 1,1000);

		gl.viewport(0, 0, width, height);
	}







	function touchHandler(event)
	{
		var touches = event.changedTouches,
		first = touches[0],
		type = "";
		switch(event.type)
		{
			case "touchstart": type = "mousedown"; break;
			case "touchmove":  type = "mousemove"; break;        
			case "touchend":   type = "mouseup";   break;
			default:           return;
		}

		var simulatedEvent = document.createEvent("MouseEvent");
		simulatedEvent.initMouseEvent(type, true, true, window, 1, 
									first.screenX, first.screenY, 
									first.clientX, first.clientY, false, 
									false, false, false, 0/*left*/, null);

		first.target.dispatchEvent(simulatedEvent);
		event.preventDefault();
	}

	document.addEventListener("touchstart", touchHandler, true);
	document.addEventListener("touchmove", touchHandler, true);
	document.addEventListener("touchend", touchHandler, true);
	document.addEventListener("touchcancel", touchHandler, true);    







	function mouseMove(event) {
		if (mouseDown) {
			var nMouseX = event.clientX-(width-canvas.width)/2+0.5-canvas.width/2;
			var nMouseY = event.clientY-(height-canvas.height)/2-canvas.height/2;
			rotX += (mouseX-nMouseX)/2;
			rotY += (mouseY-nMouseY)/2;
			mouseX = nMouseX;
			mouseY = nMouseY;
			if (rotY>180) {
				rotY = 180;
			} else if (rotY<-180) {
				rotY = -180;
			}
		}
	}
	function wheel(event)
	{
		if(event.deltaX>0 || event.deltaY>0 || event.deltaZ>0) {
			lookDistance+=2.5;
		}
		else if(event.deltaX<0 || event.deltaY<0 || event.deltaZ<0) {
			lookDistance-=2.5;
			if(lookDistance<0)
				lookDistance=0;
		}
	}
	function mouseClickDown(event) {
		event.preventDefault = true;
		canvas.style.cssText = canvas.style.cssText + "cursor:move;";
		mouseDown = true;
		mouseX = event.clientX-(width-canvas.width)/2+0.5-canvas.width/2;
		mouseY = event.clientY-(height-canvas.height)/2-canvas.height/2;
		return false;
	}
	function mouseClickUp(event) {
		canvas.style.cssText = canvas.style.cssText + "cursor:default;";
		mouseDown = false;
	}
	function contextMenu(event){
		event.preventDefault = true;
		return false;
	}
	function keysDown(event) {
		event.preventDefault = true;
		keys[event.keyCode] = true;
		return false;
	}
	function keysUp(event) {
		keys[event.keyCode] = false;
	}


	var out=[];
	var x;
	var y;
	var z;

	var a00;
	var a01;
	var a02;
	var a03;
	
	var a10;
	var a11;
	var a12;
	var a13;
	
	var a20;
	var a21;
	var a22;
	var a23;
	
	var a30;
	var a31;
	var a32;
	var a33;

	var b0;
	var b1;
	var b2;
	var b3;

	function multiply(a, b) {
		a00 = a[0];
		a01 = a[1];
		a02 = a[2];
		a03 = a[3];
		a10 = a[4];
		a11 = a[5];
		a12 = a[6];
		a13 = a[7];
		a20 = a[8];
		a21 = a[9];
		a22 = a[10];
		a23 = a[11];
		a30 = a[12];
		a31 = a[13];
		a32 = a[14];
		a33 = a[15];

		b0 = b[0];
		b1 = b[1];
		b2 = b[2];
		b3 = b[3];

		out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		b3 = b[7];

		out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		b3 = b[11];

		out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		b3 = b[15];

		out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		return out;
	}
	function createTransformation(r,t,rp,s) {
		z = r[2]*0.0174444444444444;
		y = r[1]*0.0174444444444444;
		x = r[0]*0.0174444444444444;
		return  multiply(
					multiply(
						multiply(
							multiply(
								multiply(
									multiply(
									[s,		0.0,		0.0,		0.0,
									0.0,		s,			0.0,		0.0,
									0.0,		0.0,		s,			0.0,
									0.0,		0.0,		0.0,		1.0],

									[1.0,	0.0,		0.0,		-rp[0],
									0.0,		1.0,		0.0,		-rp[1],
									0.0,		0.0,		1.0,		-rp[2],
									0.0,		0.0,		0.0,		1.0]),
				
							 	[Math.cos(r[2]*0.0174444444444444),	-Math.sin(r[2]*0.0174444444444444),	0.0,		0.0,
								Math.sin(r[2]*0.0174444444444444),	Math.cos(r[2]*0.0174444444444444),	0.0,		0.0,
								0.0,		0.0,		1.0,		0.0,
								0.0,		0.0,		0.0,		1.0]) ,

							[Math.cos(r[1]*0.0174444444444444),	0.0,		Math.sin(r[1]*0.0174444444444444),	0.0,
							0.0,		1.0,		0.0,		0.0,
							-Math.sin(r[1]*0.0174444444444444),	0.0,		Math.cos(r[1]*0.0174444444444444),	0.0,
							0.0,		0.0,		0.0,		1.0]) ,

						[1.0,		0.0,		0.0,		0.0,
						0.0,		Math.cos(r[0]*0.0174444444444444),	-Math.sin(r[0]*0.0174444444444444),	0.0,
						0.0,		Math.sin(r[0]*0.0174444444444444),	Math.cos(r[0]*0.0174444444444444),	0.0,
						0.0,		0.0,		0.0,		1.0]) ,

					[1.0,		0.0,		0.0,		rp[0],
					0.0,		1.0,		0.0,		rp[1],
					0.0,		0.0,		1.0,		rp[2],
					0.0,		0.0,		0.0,		1.0]) ,

				[1.0,		0.0,		0.0,		t[0],
				0.0,		1.0,		0.0,		t[1],
				0.0,		0.0,		1.0,		t[2],
				0.0,		0.0,		0.0,		1.0]);
	}
	function createTransformationS(t,s) {
		return  [s,			0.0,		0.0,		t[0],
				 0.0,		s,			0.0,		t[1],
				 0.0,		0.0,		s,			t[2],
				 0.0,		0.0,		0.0,		1.0]
	}

	function createPerspective(fovy, asp, near, far) {
		var f = 1.0 / Math.tan(fovy / 2),
			nf = 1.0 / (near - far);
		var out = [];
		out[0] = f / asp;
		out[1] = 0;
		out[2] = 0;
		out[3] = 0;
		out[4] = 0;
		out[5] = f;
		out[6] = 0;
		out[7] = 0;
		out[8] = 0;
		out[9] = 0;
		out[10] = (far + near) * nf;
		out[11] = -1;
		out[12] = 0;
		out[13] = 0;
		out[14] = (2 * far * near) * nf;
		out[15] = 0;
		return out;
	}
}
		</script>














		<script type="text/javascript">
var error = function(msg) {
	if (window.console) {
		if (window.console.error) {
			window.console.error(msg);
		}
		else if (window.console.log) {
			window.console.log(msg);
		}
	}
};

var loadShader = function(gl, shaderSource, shaderType, opt_errorCallback) {
	var errFn = opt_errorCallback || error;
	var shader = gl.createShader(shaderType);
	gl.shaderSource(shader, shaderSource);
	gl.compileShader(shader);
	var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	if (!compiled) {
		var lastError = gl.getShaderInfoLog(shader);
		errFn("*** Error compiling shader '" + shader + "':" + lastError);
		gl.deleteShader(shader);
		return null;
	}

	return shader;
};

var loadProgram = function(
		gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
	var errFn = opt_errorCallback || error;
	var program = gl.createProgram();
	for (var ii = 0; ii < shaders.length; ++ii) {
		gl.attachShader(program, shaders[ii]);
	}
	if (opt_attribs) {
		for (ii = 0; ii < opt_attribs.length; ++ii) {
			gl.bindAttribLocation(
				program,
				opt_locations ? opt_locations[ii] : ii,
				opt_attribs[ii]);
		}
	}
	gl.linkProgram(program);
	var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
	if (!linked) {
		var lastError = gl.getProgramInfoLog (program);
		errFn("Error in program linking:" + lastError);
		gl.deleteProgram(program);
		return null;
	}
	return program;
};

var createShaderFromScript = function(gl, scriptId, opt_shaderType, opt_errorCallback) {
	var shaderSource = "";
	var shaderType;
	var shaderScript = document.getElementById(scriptId);
	if (!shaderScript) {
		throw("*** Error: unknown script element" + scriptId);
	}
	shaderSource = shaderScript.text;

	if (!opt_shaderType) {
		if (shaderScript.type == "x-shader/x-vertex") {
			shaderType = gl.VERTEX_SHADER;
		} else if (shaderScript.type == "x-shader/x-fragment") {
			shaderType = gl.FRAGMENT_SHADER;
		} else if (shaderType != gl.VERTEX_SHADER && shaderType != gl.FRAGMENT_SHADER) {
			throw("*** Error: unknown shader type");
			//return null;
		}
	}

	return loadShader(
		gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
		opt_errorCallback);
};

var defaultShaderType = [
	"VERTEX_SHADER",
	"FRAGMENT_SHADER"
];

var createProgramFromScripts = function(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
	var shaders = [];
	for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
		shaders.push(createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));
	}
	return loadProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
};
		</script>
	
</body></html>